// В массиве Digits хранятся схемы отображения цифр 0-9. Схема отображения (с.о.) -- это байт, в котором
// каждый бит соответствует сегменту 7-сегментного индикатора. Младший (нулевой) бит соответствует
// сегменту A, первый бит сегменту B, ..., шестой бит сегменту G, старший (седьмой) бит точке (сегменту H).
// Интерпретация с.о.: если бит=0, то соответствующий сегмент должен быть погашен, если 1 -- зажжён. 
// С.о. хранятся в массиве последовательно, начиная с с.о. для цифры 0 и заканчивая с.о. для цифры 9. 
// Например, чтобы найти с.о. для цифры 1, нужно взять элемент Digits[1]. Это байт 00000110, он указывает,
// что необходимо зажечь сегменты B и C, а остальные погасить.

byte Digits[10] = {0b00111111, 0b00000110, 0b01011011, 0b01001111, 0b01100110,
                   0b01101101, 0b01111101, 0b00000111, 0b01111111, 0b01101111};

byte mode = 0;  // Режим интерпретации входных данных. 
                // Если mode=0, то принимаются и отображаются только десятичные цифры 0-9 согласно схеме отображения 
                // (режим с декодированием).
                // Режим без декодирования реализуется при mode=1, он даёт возможность управлять включать и
                // выключать сегменты индивидуально. Принимается двоичное число, заданное строкой длиной от 1 до 8 символов,
                // которыми могут быть только 0 и 1. Младший разряд в этой строке соответствует сегменту A индикатора, первый сегменту B, и т.д.,
                // старший сегменту H (точке). Единица, записанная в разряд, зажигает соответствующий сегмент, нуль гасит его.

void setup()
{
 Serial.begin(9600);
 DDRD |= 0b11111100; // пины 2-7 настроить как выходы
 DDRB |= 0b00000011; // пины 8,9 настроить как выходы
}


void loop()
{
 if (Serial.available()) {
    String key = Serial.readStringUntil('=');         // Индикатор управляется вводом в монитор последовательного порта
    String val = Serial.readStringUntil('\n');        // команд вида параметр=значение. Монитор п.п. должен дополнить
    //  Serial.println("Key: " + key);                // команду символом новой строки \n.
    //  Serial.println("Val: " + val);                // Допускаются два параметра, m (mode) и v (value).
                                                      // Команда m=0 включает режим с декодированием, m=1 режим без декодирования.
                                                      // Команда v=значение вызывает отображение этого значения на индикаторе.
                                                      // В режиме 0 в качестве значения принимаются цифры 0-9: v=2, v=0 и т.п.
                                                      // В режиме 1 принимается записанное строкой двоичное число, например,
                                                      // v=00010100, v=010, v=0.

    
    if (key == "m" and (val == "0" or val == "1")) {  // обработка команды m=значение
     mode = val[0] - '0';           
     Serial.print("mode: ");
     Serial.println(mode); 
    }

    if (key == "v" and mode == 0 and val.length() == 1) { // обработка команды v=значение при mode=0 (цифры 0-9)
     byte digit = val[0] - '0';
     if (digit >=0 and digit <=9) Display(Digits[digit]);
    }

    if (key == "v" and mode == 1) Display(StrToBin(val)); // обработка команды v=значение при mode=1 (индивидуальные сегменты)
 }
}

byte StrToBin(String inString) {
// Функция принимает строку из нулей и единиц длиной 1-8 символов и преобразует её в байт как двоичное число
// Если передано 0 или более 8 символов, если среди символов есть отличные от 0 и 1, то результатом является 0, что соответствует
// гашению всех сегментов индикатора

 int len = inString.length();
 if (len < 1 or len > 8) return 0;
 byte result = 0;
 byte mask = 1;
 for (int i = len - 1; i >= 0; i--) {
  if (inString[i] != '0' and inString[i] != '1') return 0;
  if (inString[i] == '1') result = result|mask;
  mask = mask << 1;
 };
 return result;  
}



void Display(byte digit) {

// Принимает байт, интерпретирует его как схему отображения для 7-сегментного индикатора
// (информацию о том, какие сегменты зажечь, а какие погасить) и выдаёт в порты B и D данные для отображения.
// Т.к. 6 сегментов индикатора (A-F) подключены к порту D и 2 к порту B, принятый байт
// должен быть поделён на две части и распределён по портам, притом так,
// чтобы не были затронуты биты портов, не относящиеся к отображению цифры. 

 PORTB &= 0b11111100; // погасить сегменты, подключённые к порту B, не затрагивая два младших бита порта
 byte b = digit >> 6; // сдвинуть принятый байт вправо нв 6 позиций, чтобы
                      // два старших бита схемы оказались младшими битами в b 
 b |= 0b11111100;     // в старшие биты b поместить 6 единиц, сохранив два младших бита
 PORTB |= b;          // выдать два младших бита в PORTB, не затрагивая шесть старших


// Для порта D выполняется аналогичная операция, но схема отображения сдвигается влево на 2 бита
 PORTD &= 0b00000011;
 PORTD |= (digit << 2) | 0b00000011;
}


/*
Иллюстративная программа для управления семисегментным индикатором через последовательный порт.
Программа принимает через Serial Monitor в Arduino IDE и UART в Arduino UNO команду
установки режима m=0 или m=1 и команду отображения v=значение. Значение, переданное в команде v,
отображается на индикаторе по-разному в зависимости от режима, установленного командой m.

Если передана команда m=0, то устанавливается режим с декодированием. В этом режиме в команде v можно
передавать только цифры 0-9, и они будут отображаться на индикаторе в соответствии со схемой отображения,
заданной в массиве Digits.

Если передана команда m=1, то устанавливается режим без декодирования. В этом режиме в команде v
передаётся двоичное число, в котором каждый разряд управляет соответствующим сегментом индикатора. В этом
режиме можно отображать произвольную комбинацию сегментов, а не только цифры. 

Индикатор с общим катодом подключён к плате Arduino UNO:
- общий катод к GND
- аноды сегментов A, B, C, D, E, F, G и анод точки (сегмента H) к пинам 2-9 соответственно через токоограничивающие резисторы.
 */