void setup()
{
 Serial.begin(9600);
  DDRB |= 0b00111111;   // шесть младших пинов PortB (8-13) настроить как выход
  DDRD |= 0b11111100;   // и шесть старших пинов PortD (2-7) тоже
}


void loop()
{
 volatile uint8_t* port;  // переменная-указатель на порт (на 8-разрядное целое без знака). Пояснение зачем volatile см. в длинном комментарии в конце. 
 byte mask; // маска для заданного пина

 if (Serial.available()) {
    String val = Serial.readStringUntil('\n'); 
    long pin = val.toInt();
    if (pin < 2 or pin > 13) return; // контроль введенных значений. Управляются только пины 2-13.
    
    // Порт и маска, которые должны использоваться для данного пина 
    if ( pin < 8 ) {
        port = &PORTD; // адрес регистра PORTD (оператор & — «получить адрес»; в переменную-указатель port записывается адрес, по которому находится регистр PORTD)
        mask = 1 << pin; //маска по пину. Для пина 2 маска 00000100 (0b00000001 (=1) сдвинуть влево 2 раза). Для пина n сдвинуть влево n раз.
    } else {
        port = &PORTB;
        mask = 1<<(pin-8);
    }
    
    *port ^= mask; // инверсия состояния заданного пина (считывание и присваивание через указатель; XOR (^) для инверсии)
    
    // Serial.println(pin);
  }
}

/*
Иллюстративная программа для управления через последовательный порт светодиодами, подключёнными к пинам 2-13 платы Arduino UNO.
Анод светодиода через токоограничивающий резистор подключают к пину, катод на GND.
В Serial monitor в Arduino IDE вводят номер пина 2-13, подключённым к которому светодиодом хотят управлять, и завершают ввод нажатием ENTER.
Состояние светодиода меняется на противоположное (горит - не горит).

В программе:
- настраивают порты B и D на работу в качестве выходов;
- принятую строку преобразуют в десятичное число;
- если это получилось, то проверяют число на вхождение в допустимый диапазон 2-13;
- определяют порт и маску, соответствующие принятому номеру пина;
- считывают состояние порта, выполняют XOR между считанным состоянием порта и маской, результат записывают в тот же порт.

Почему volatile? Регистры портов — аппаратные, они могут меняться не только программой (от внешних сигналов, таймеров и т.д.).
volatile указывает компилятору: «Не оптимизируй обращения к этой памяти, читай/пиши каждый раз реально».
Без volatile компилятор мог бы закэшировать значение в регистре CPU и не видеть реальное состояние порта.

Обращение к порту через указатель
volatile uint8_t* port = &PORTD;  // переменная-указатель port указывает на PORTD
byte A = *port;                   // байту А присваивается значение, считанное из PORTD
*port = 0xFF;                     // в PORTD выдаётся 0xFF

 */