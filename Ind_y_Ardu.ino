// В массиве Digits хранятся схемы отображения цифр 0-9. Схема отображения (с.о.) -- это байт, в котором
// каждый бит соответствует сегменту 7-сегментного индикатора. Младший (нулевой) бит соответствует
// сегменту A, первый бит сегменту B, ..., шестой бит сегменту G, старший (седьмой) бит точке (сегменту H).
// Интерпретация с.о.: если бит=0, то соответствующий сегмент должен быть погашен, если 1 -- зажжён. 
// С.о. хранятся в массиве последовательно, начиная с с.о. для цифры 0 и заканчивая с.о. для цифры 9. 
// Например, чтобы найти с.о. для цифры 1, нужно взять элемент Digits[1]. Это байт 00000110, он указывает,
// что необходимо зажечь сегменты B и C, а остальные погасить.

byte Digits[10] = {0b00111111, 0b00000110, 0b01011011, 0b01001111, 0b01100110,
                   0b01101101, 0b01111101, 0b00000111, 0b01111111, 0b01101111};



void setup()
{
 Serial.begin(9600);
 DDRD |= 0b11111100; // пины 2-7 настроить как выходы
 DDRB |= 0b00000001; // пин 8 настроить как выход
}


void loop()
{
 char c = Serial.read();         // Прочитать байт из буфера последовательного порта.
                                 // Функция read возвращает int с кодом символа, а при отсутствии данных в буфере минус единицу,
                                 // что будет отфильтровано в дальнейшей обработке

 if (c >= '0' && c <= '9') {     // если принятый сивол цифра, то
  byte n = c - '0';   // 0 … 9   // представить её байтом, содержащим эту цифру (а не код), для чего из кода принятого символа вычесть код символа '0'
  Display(n);                    // отобразить цифру на 7-сегментном индикаторе
 }
}



void Display(byte digit) {

// Принимает цифру 0-9 и выдаёт в порты B и D данные для её отображения на 7-сегментном индикаторе.
// Информация о том, какие сегменты зажечь, а какие погасить, для цифры i хранится в Digits[i].
// Т.к. 6 сегментов индикатора (A-F) подключены к порту D и 2 к порту B, байт,
// принятый из Digits[i], должен быть поделён на две части и распределён по портам, притом так,
// чтобы не были затронуты биты портов, не относящиеся к отображению цифры. 

 PORTB &= 0b11111100; // погасить сегменты, подключённые к порту B, не затрагивая два младших бита порта
 byte b = Digits[digit] >> 6 ; // принять из Digits схему отображения и сдвинуть её вправо нв 6 позиций, чтобы
                               // два старших бита схемы оказались младшими битами в b 
 b |= 0b11111100;              // в старшие биты b поместить 6 единиц, сохранив два младших бита
 PORTB |= b;                   // выдать два младших бита в PORTB, не затрагивая шесть старших
                               // (2 бита для сегментов G и H, но в этой задаче H не используется и 
                               // в принципе достаточно выдать 1 младший бит, не затрагивая 7 старших) 


// Для порта D выполняется аналогичная операция, но с.о. сдвигается влево на 2 бита
 
 PORTD &= 0b00000011;
 PORTD |= (Digits[digit] << 2) | 0b00000011;
}


/*
Иллюстративная программа для управления семисегментным индикатором через последовательный порт.
Программа отображает на индикаторе цифру 0-9, переданную через Serial Monitor в Arduino IDE и принятую в Arduino UNO.

Индикатор с общим катодом подключён к плате Arduino UNO:
- общий катод к GND
- аноды сегментов A, B, C, D, E, F, G к пинам 2-8 соответственно через токоограничивающие резисторы
(в этой программе десятичная точка индикатора не используется и управление ей не предусмотрено).
 */