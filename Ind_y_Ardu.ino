#define COMMON_CATHODE true         // true для индикатора с общим катодом, false для индикатора с общим анодом

/* В массиве Digits хранятся схемы отображения цифр 0-9. Схема отображения (с.о.) -- это байт, в котором
каждый бит соответствует сегменту 7-сегментного индикатора. Младший (нулевой) бит соответствует
сегменту A, первый бит сегменту B, ..., шестой бит сегменту G, старший (седьмой) бит точке (сегменту H).
Если в с.о. бит=0, то соответствующий сегмент должен быть погашен, если 1 -- зажжён. 
С.о. хранятся в массиве последовательно, начиная с с.о. для цифры 0 и заканчивая с.о. для цифры 9. 
Например, чтобы найти с.о. для цифры 1, нужно взять элемент Digits[1]. Это байт 00000110, он указывает,
что необходимо зажечь сегменты B и C, а остальные погасить. */

const byte Digits[10] = {0b00111111, 0b00000110, 0b01011011, 0b01001111, 0b01100110,
                         0b01101101, 0b01111101, 0b00000111, 0b01111111, 0b01101111};

const String modes[2] = {"0", "1"}; // возможные значения режима, передаваемые в команде m=значение
constexpr size_t length_modes = sizeof(modes) / sizeof(modes[0]); //количество элементов массива modes. length на константных массивах не работает.
                                                                  //size_t — тип, предназначенный для хранения размеров и индексов в памяти
                                                                  //constexpr — это ключевое слово С++11, которое говорит компилятору:
                                                                  //«вычисли значение во время компиляции, если возможно, и сделай его константой».  

byte mode = 1;  // Режим интерпретации входных данных. Здесь задан режим без декодирования, чтобы при старте отобразить прочерк.
byte pos = 0;   // Текущая позиция (разряд) индикатора. 0 соответствует младшему разряду, 1 старшему, другие значения не допускаются

/* Если mode=0, то принимаются и отображаются только десятичные цифры 0-9 согласно схеме отображения (режим с декодированием).
Режим без декодирования реализуется при mode=1, он даёт возможность включать и выключать сегменты индивидуально. 
Принимается двоичное число, заданное строкой длиной от 1 до 8 символов, которыми могут быть только 0 и 1. Младший разряд в этой строке
соответствует сегменту A индикатора, первый сегменту B, и т.д., старший сегменту H (точке). Единица, записанная в разряд, зажигает 
соответствующий сегмент, нуль гасит его. */

void setup()
{
 Serial.begin(9600);
 DDRD |= 0b11111100; // пины 2-7 настроить как выходы
 DDRB |= 0b00001111; // пины 8-11 настроить как выходы
 Display(0, 0b01000000); // отобразить прочерк (дефис) в младшем  разряде индикатора
 mode = 0; // перейти в режим с декодированием    
}


void loop()
{
/* Индикатор управляется вводом в монитор последовательного порта команд вида параметр=значение. Монитор п.п. 
должен быть настроен на дополнение введённых данных символом новой строки \n.
Допускаются 3 команды, m (mode, режим), p (position, позиция) и v (value, значение).
Команда m=0 включает режим с декодированием, m=1 режим без декодирования.
Командой v=значение вводится значение, которое обрабатывается и отображается на индикаторе в позиции p
в соответствии с режимом, заданным командой m.
В режиме 0 в качестве значения принимаются цифры 0-9: v=2, v=0 и т.п.
В режиме 1 принимается записанное строкой двоичное число, например, v=00010100, v=010, v=0.
В качестве номера позиции p допускаются только значения 0 (отобразить в младшем разряде индикатора) и 1 (в старшем).  */
 
 
 if (Serial.available()) {
    String key = Serial.readStringUntil('=');         
    String val = Serial.readStringUntil('\n');        
    //  Serial.println("Key: " + key);                
    //  Serial.println("Val: " + val);                
    
    if (key == "m" and isAllowed(val)) {  // обработка команды m=значение
     mode = val[0] - '0';           
     Serial.print("mode: ");
     Serial.println(mode); 
    }


    if (key == "p") { // обработка команды p=значение
     pos = val[0] - '0';
     if (pos < 0 or pos > 1) pos=0; // при p, отличном от 0 и 1, pos задаётся равным 0
     Serial.print("pos: ");
     Serial.println(pos);  
    }


   if (key == "v") { // обработка команды v=значение

    if (mode==0 and val.length() == 1) {      // обработка команды v=значение при mode=0 (цифры 0-9)
        byte digit = val[0] - '0';
        if (digit >=0 and digit <=9) Display(pos, Digits[digit]);
    }
    if (mode==1) Display(pos, StrToBin(val));      // обработка команды v=значение при mode=1 (индивидуальные сегменты)
   } 
 }
}


bool isAllowed(String value) {
// Проверяет, находится ли принятая строка value в списке modes

 bool result = false;
 for (byte i = 0; i < length_modes; i++) { 
   result = (value == modes[i]);
   if (result) break;
 }
 return result; 
}



void Display(byte position, byte digit) {
// отображение символа, заданного байтом digit, в позиции двухразрядного индикатора, определяемой байтом position

// Принимает данные в виде двух байтов, гасит все сегменты индикатора, и в заданной позиции зажигает сегменты,
// соответствующие единицам в двоичном представлении принятого байта
// (сегмент A -- младший бит, и далее последовательно BCDEFG, точке H соответствует старший бит)

/* Двухразрядный индикатор подключён к Arduino UNO: сегменты A-F к порту D (контакты 3-8), сегменты G, H к порту B (контакты 9, 10),
общие электроды младшего и старшего разряда к порту B (контакты 11, 12).
Соответственно, байт, подлежащий отображению, должен быть поделён на две части и распределён по портам, притом так,
чтобы не изменились состояния выходов портов, к которым индикатор не подключён.
Сначала выполняется гашение всех сегментов, затем зажигание нужных.
В этой программе сегмент гасится подачей на него обратного напряжения (т.е. подачей на анод отрицательного потенциала по отношению
к катоду). Такой подход требует, чтобы индикатор, подключённый напрямую к Arduino, выдерживал обратное напряжение 5 В, или сегменты
должны быть шунтированы обратно включёнными кремниевыми диодами. 
 Алгоритм разделения принятого байта на две части и его выдачи в порты
 Для порта B
 byte b = digit >> 6; // сдвинуть принятый байт вправо на 6 позиций, чтобы два старших бита digit оказались младшими битами b 
 b |= 0b11111100;     // в старшие биты b поместить 6 единиц, сохранив два младших бита
 PORTB |= b;          // выдать два младших бита в PORTB, не затрагивая шесть старших
 Для порта D то же самое, но сдвиг влево на 2 бита. Запись в одну строку 
 PORTD |= (digit << 2) | 0b00000011; */

 const byte mask_B = 0b11111100;
 const byte mask_D = 0b00000011;
 byte mask_B_pos = 0b00000100 << position; // маска для выбора разряда индикатора -- нулевого или первого
 byte shiftedDigit_B = digit >> 6;
 byte shiftedDigit_D = digit << 2;

 if (COMMON_CATHODE) { // общий катод
   PORTB &= mask_B;                    // гасим по линиям сегментов, выставляя на них низкий уровень 
   PORTD &= mask_D;
   PORTB |= 0b00001100;                // гасим по линиям катодов, выставляя на них высокий уровень. На погашенных сегментах обратное напряжение!
   PORTB |= (shiftedDigit_B | mask_B); // подаём высокий уровень на сегменты, которые нужно зажечь
   PORTD |= (shiftedDigit_D | mask_D); 
   PORTB &= ~mask_B_pos;                // подаём низкий уровень на общий катод нужного разряда (задаётся параметром position)
  } 
 else { // общий анод (эта часть написана по аналогии, на реальной системе не проверялась, в отличие от части для общего катода)
   PORTB |= ~mask_B;                     // гасим по линиям сегментов, выставляя на них высокий уровень
   PORTD |= ~mask_D;
   PORTB &= 0b11110011;                  // гасим по линиям анодов, выставляя на них низкий уровень. На погашенных сегментах обратное напряжение! 
   PORTB &= (~shiftedDigit_B & ~mask_B); // подаём низкий уровень на сегменты, которые нужно зажечь
   PORTD &= (~shiftedDigit_D & ~mask_D);
   PORTB |= mask_B_pos;                  // подаём высокий уровень на общий анод нужного разряда (задаётся параметром position)
  };
}



byte StrToBin(String inString) {
/* Функция принимает строку из нулей и единиц длиной 1-8 символов и преобразует её в байт как двоичное число
Если передано 0 или более 8 символов, если среди символов есть отличные от 0 и 1, то результатом является 0, что соответствует
гашению всех сегментов индикатора */

 int len = inString.length();
 if (len < 1 or len > 8) return 0;
 byte result = 0;
 byte mask = 1;
 for (int i = len - 1; i >= 0; i--) {
  if (inString[i] != '0' and inString[i] != '1') return 0;
  if (inString[i] == '1') result = result|mask;
  mask = mask << 1;
 };
 return result;  
}


/*
Иллюстративная программа для управления двухразрядным семисегментным индикатором через последовательный порт.
Программа принимает через Serial Monitor в Arduino IDE и UART в Arduino UNO команду
установки режима отображения m=0 или m=1, команду выбора разряда индикатора p=значение, команду отображения v=значение.
Значение, переданное в команде v, отображается на индикаторе по-разному в зависимости от режима, установленного командой m.

Если передана команда m=0, то устанавливается режим с декодированием. В этом режиме в команде v можно
передавать только цифры 0-9, и они будут отображаться на индикаторе в соответствии со схемой отображения,
заданной в массиве Digits.

Если передана команда m=1, то устанавливается режим без декодирования. В этом режиме в команде v
передаётся двоичное число, в котором каждый разряд управляет соответствующим сегментом индикатора. В этом
режиме можно отображать произвольную комбинацию сегментов, а не только цифры.

Разряд индикатора, в котором отображается требуемая цифра или комбинация сегментов, выбирается командой p=значение.
Можно погасить весь индикатор либо отобразить знак в одном из разрядов индикатора, но не в двух разрядах одноременно.

Двухразрядный семисегментный индикатор с общим катодом или общим анодом подключён к плате Arduino UNO:
- общий электрод младшего и старшего разряда к пинам 11, 12 соответственно
- сегменты A, B, C, D, E, F, G и точка (сегмент H) к пинам 2-9 соответственно через токоограничивающие резисторы.
В программе до компиляции необходимо указать тип индикатора
(в строке #define COMMON_CATHODE false   // true для индикатора с общим катодом, false для индикатора с общим анодом)
 */

 