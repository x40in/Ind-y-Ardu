#define COMMON_CATHODE true         // true для индикатора с общим катодом, false для индикатора с общим анодом

/* В массиве Digits хранятся схемы отображения цифр 0-9. Схема отображения (с.о.) -- это байт, в котором
каждый бит соответствует сегменту 7-сегментного индикатора. Младший (нулевой) бит соответствует
сегменту A, первый бит сегменту B, ..., шестой бит сегменту G, старший (седьмой) бит точке (сегменту H).
Интерпретация с.о.: если бит=0, то соответствующий сегмент должен быть погашен, если 1 -- зажжён. 
С.о. хранятся в массиве последовательно, начиная с с.о. для цифры 0 и заканчивая с.о. для цифры 9. 
Например, чтобы найти с.о. для цифры 1, нужно взять элемент Digits[1]. Это байт 00000110, он указывает,
что необходимо зажечь сегменты B и C, а остальные погасить. */

const byte Digits[10] = {0b00111111, 0b00000110, 0b01011011, 0b01001111, 0b01100110,
                         0b01101101, 0b01111101, 0b00000111, 0b01111111, 0b01101111};

const String modes[2] = {"0", "1"}; // возможные значения режима, передаваемые в команде m=значение
constexpr size_t length_modes = sizeof(modes) / sizeof(modes[0]); //количество элементов массива modes. length на константных массивах не работает
                                                                  //size_t — тип, предназначенный для хранения размеров и индексов в памяти
                                                                  //constexpr — это ключевое слово С++11, которое говорит компилятору:
                                                                  //«вычисли значение во время компиляции, если возможно, и сделай его константой».  

byte mode = 0;  // Режим интерпретации входных данных. 

/* Если mode=0, то принимаются и отображаются только десятичные цифры 0-9 согласно схеме отображения (режим с декодированием).
Режим без декодирования реализуется при mode=1, он даёт возможность управлять включать и выключать сегменты индивидуально. 
Принимается двоичное число, заданное строкой длиной от 1 до 8 символов, которыми могут быть только 0 и 1. Младший разряд в этой строке
соответствует сегменту A индикатора, первый сегменту B, и т.д., старший сегменту H (точке). Единица, записанная в разряд, зажигает 
соответствующий сегмент, нуль гасит его. */

void setup()
{
 Serial.begin(9600);
 DDRD |= 0b11111100; // пины 2-7 настроить как выходы
 DDRB |= 0b00000011; // пины 8,9 настроить как выходы
 Display(0);         // погасить все сегменты
}


void loop()
{
/* Индикатор управляется вводом в монитор последовательного порта команд вида параметр=значение. Монитор п.п. 
должен быть настроен на дополнение введённых данных символом новой строки \n.
Допускаются две команды, m (mode, режим) и v (value, значение).
Команда m=0 включает режим с декодированием, m=1 режим без декодирования, m=2 режим гадания
Командой v=значение вводится значение, которое обрабатывается и отображается на индикаторе 
в соответствии с режимом, заданным командой m=режим.
В режиме 0 в качестве значения принимаются цифры 0-9: v=2, v=0 и т.п.
В режиме 1 принимается записанное строкой двоичное число, например, v=00010100, v=010, v=0.
В режиме 2 принимается записанное строкой десятичное число, например, v=569, v=010, v=0. */
 
 
 if (Serial.available()) {
    String key = Serial.readStringUntil('=');         
    String val = Serial.readStringUntil('\n');        
    //  Serial.println("Key: " + key);                
    //  Serial.println("Val: " + val);                
    
    if (key == "m" and isAllowed(val)) {  // обработка команды m=значение
     mode = val[0] - '0';           
     Serial.print("mode: ");
     Serial.println(mode); 
    }


   if (key == "v") { // обработка команды v=значение

    if (mode==0 and val.length() == 1) {      // обработка команды v=значение при mode=0 (цифры 0-9)
        byte digit = val[0] - '0';
        if (digit >=0 and digit <=9) Display(Digits[digit]);
    }
    if (mode==1) Display(StrToBin(val));      // обработка команды v=значение при mode=1 (индивидуальные сегменты)
   } 
 }
}


bool isAllowed(String value) {
// Проверяет, находится ли принятая строка value в списке modes

 bool result = false;
 for (byte i = 0; i < length_modes; i++) { 
   result = (value == modes[i]);
   if (result) break;
 }
 return result; 
}


void Display(byte digit) {
//  Принимает байт, гасит все сегменты индикатора и зажигает сегменты, соответствующие единицам в двоичном представлении принятого байта
// (сегмент A -- младший бит, и далее последовательно BCDEFG, точке H соответствует старший бит)

/* Индикатор подключён к Arduino UNO: сегменты A-F к порту D (контакты 3-8), сегменты G, H к порту B (контакты 9, 10)
Соответственно, байт, подлежащий отображению, должен быть поделён на две части и распределён по портам, притом так,
чтобы не изменились состояния выходов портов, к которым индикатор не подключён.
Сначала выполняется гашение всех сегментов, затем зажигание нужных.
Для гашения сегмента индикатора с общим катодом в порт должен быть выдан низкий потенциал, с общим анодом высокий.
Для зажигания сегмента индикатора с общим катодом в порт должен быть выдан высокий потенциал, с общим анодом низкий.
 Алгоритм разделения принятого байта на две части и его выдачи в порты
 Для порта B
 byte b = digit >> 6; // сдвинуть принятый байт вправо нв 6 позиций, чтобы два старших бита digit оказались младшими битами b 
 b |= 0b11111100;     // в старшие биты b поместить 6 единиц, сохранив два младших бита
 PORTB |= b;          // выдать два младших бита в PORTB, не затрагивая шесть старших
 Для порта D то же самое, но сдвиг влево на 2 бита. Запись в одну строку 
 PORTD |= (digit << 2) | 0b00000011; */

 const byte mask_B = 0b11111100;
 const byte mask_D = 0b00000011;
 byte shiftedDigit_B = digit >> 6;
 byte shiftedDigit_D = digit << 2;

 if (COMMON_CATHODE) { // общий катод
   PORTB &= mask_B;                    // гасим 
   PORTD &= mask_D; 
   PORTB |= (shiftedDigit_B | mask_B); // зажигаем
   PORTD |= (shiftedDigit_D | mask_D); 
  } 
 else { // общий анод
   PORTB |= ~mask_B;                     // гасим
   PORTD |= ~mask_D;
   PORTB &= (~shiftedDigit_B & ~mask_B); // зажигаем
   PORTD &= (~shiftedDigit_D & ~mask_D); 

  };
}



byte StrToBin(String inString) {
/* Функция принимает строку из нулей и единиц длиной 1-8 символов и преобразует её в байт как двоичное число
Если передано 0 или более 8 символов, если среди символов есть отличные от 0 и 1, то результатом является 0, что соответствует
гашению всех сегментов индикатора */

 int len = inString.length();
 if (len < 1 or len > 8) return 0;
 byte result = 0;
 byte mask = 1;
 for (int i = len - 1; i >= 0; i--) {
  if (inString[i] != '0' and inString[i] != '1') return 0;
  if (inString[i] == '1') result = result|mask;
  mask = mask << 1;
 };
 return result;  
}


/*
Иллюстративная программа для управления семисегментным индикатором через последовательный порт.
Программа принимает через Serial Monitor в Arduino IDE и UART в Arduino UNO команду
установки режима m=0 или m=1 и команду отображения v=значение. Значение, переданное в команде v,
отображается на индикаторе по-разному в зависимости от режима, установленного командой m.

Если передана команда m=0, то устанавливается режим с декодированием. В этом режиме в команде v можно
передавать только цифры 0-9, и они будут отображаться на индикаторе в соответствии со схемой отображения,
заданной в массиве Digits.

Если передана команда m=1, то устанавливается режим без декодирования. В этом режиме в команде v
передаётся двоичное число, в котором каждый разряд управляет соответствующим сегментом индикатора. В этом
режиме можно отображать произвольную комбинацию сегментов, а не только цифры. 

Семисегментный ндикатор с общим катодом или общим анодом подключён к плате Arduino UNO:
- общий катод к GND либо общий анод к +5 В
- аноды сегментов A, B, C, D, E, F, G и анод точки (сегмента H) к пинам 2-9 соответственно через токоограничивающие резисторы.
В программе до компиляции необходимо указать тип индикатора
(в строке #define COMMON_CATHODE false   // true для индикатора с общим катодом, false для индикатора с общим анодом)
 */

 