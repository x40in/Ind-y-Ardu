#define COMMON_CATHODE true         // true для индикатора с общим катодом, false для индикатора с общим анодом

/* В массиве Digits хранятся схемы отображения цифр 0-9. Схема отображения (с.о.) -- это байт, в котором
каждый бит соответствует сегменту 7-сегментного индикатора. Младший (нулевой) бит соответствует
сегменту A, первый бит сегменту B, ..., шестой бит сегменту G, старший (седьмой) бит точке (сегменту H).
Если в с.о. бит=0, то соответствующий сегмент должен быть погашен, если 1 -- зажжён. 
С.о. хранятся в массиве последовательно, начиная с с.о. для цифры 0 и заканчивая с.о. для цифры 9. 
Например, чтобы найти с.о. для цифры 1, нужно взять элемент Digits[1]. Это байт 00000110, он указывает,
что необходимо зажечь сегменты B и C, а остальные погасить. */

const byte Digits[10] = {0b00111111, 0b00000110, 0b01011011, 0b01001111, 0b01100110,
                         0b01101101, 0b01111101, 0b00000111, 0b01111111, 0b01101111};

const String modes[2] = {"0", "1"}; // возможные значения режима, передаваемые в команде m=значение
constexpr size_t length_modes = sizeof(modes) / sizeof(modes[0]); //количество элементов массива modes. length на константных массивах не работает.
                                                                  //size_t — тип, предназначенный для хранения размеров и индексов в памяти
                                                                  //constexpr — это ключевое слово С++11, которое говорит компилятору:
                                                                  //«вычисли значение во время компиляции, если возможно, и сделай его константой».  

byte mode = 0;  // Режим интерпретации команды v=значение (см. ниже комментарий (1) в /* */)
byte pos = 0;   // Текущая позиция (разряд) индикатора. 0 соответствует младшему разряду, 1 старшему, другие значения не допускаются
byte dataToDisplay[2] = {Digits[7], Digits[0]}; // Байт 0 -- то, что должно отображаться в младшем разряде индикатора, 1 -- в старшем
unsigned long previousMillis = 0;  // переменная для хранения времени
uint16_t interval = 1000; // переменная для хранения интервала в миллисекундах

/* (1) Если mode=0, то принимаются и отображаются только десятичные цифры 0-9 согласно схеме отображения (режим с декодированием).
Режим без декодирования реализуется при mode=1, он даёт возможность включать и выключать сегменты индивидуально. 
Принимается двоичное число, заданное строкой длиной от 1 до 8 символов, которыми могут быть только 0 и 1. Младший разряд в этой строке
соответствует сегменту A индикатора, первый сегменту B, и т.д., старший сегменту H (точке). Единица, записанная в разряд, зажигает 
соответствующий сегмент, нуль гасит его. */




void setup() { // Инициализация
 Serial.begin(9600);
 DDRD |= 0b11111100; // пины 2-7 настроить как выходы
 DDRB |= 0b00001111; // пины 8-11 настроить как выходы
 Display(0, dataToDisplay[0]); // отобразить начальное показание -- число 07
 Display(1, dataToDisplay[1]);
}



void loop() { // Основной цикл
// 1. Выводят информацию на индикатор
// 2. Обрабатывают данные, принятые через Serial 


  // 1. Выводят информацию на индикатор
  // Через каждый interval меняют переменную position -- с 0 на 1 или с 1 на 0 -- и в этой позиции индикатора
  // выводят значение, содержащееся в соответствующей позиции массива dataToDisplay, с учётом текущего режима
  // отображения, заданного командой mode=значение.

  unsigned long currentMillis = millis();  // получают текущее время
  if (currentMillis - previousMillis >= interval) { // если прошёл interval, то
    previousMillis = currentMillis;                 // сохраняют текущее время
    byte position = currentPos();                   // меняют значение position
    Display(position, dataToDisplay[position]);     // выводят данные, подлежащие отображению, в этой position индикатора
  }


  // 2. Обрабатывают данные, принятые через Serial
  processSerial();
}




byte currentPos() { // Выдаёт значение 0 или 1, меняющееся при каждом вызове
  static bool position = 0;  // статическая переменная сохраняет значение между вызовами
  position = !position;      // bool фактически хранится как байт 0 или 1
  return position;            
}



void processSerial() { // Принимает данные через Serial и обрабатывает их

 /* Индикатором управляеют путём ввода в монитор последовательного порта команд вида параметр=значение. Монитор п.п. 
 должен быть настроен на дополнение введённых данных символом новой строки \n.
 Допускаются 4 команды: m (mode, режим), p (position, позиция), v (value, значение) и t (time, время).
 Команда m=0 включает режим с декодированием, m=1 режим без декодирования.
 Командой v=значение вводится значение, которое обрабатывается и отображается на индикаторе в позиции p
 в соответствии с режимом, заданным командой m.
 В режиме 0 в качестве значения принимаются цифры 0-9: v=2, v=0 и т.п.
 В режиме 1 принимается записанное строкой двоичное число, например, v=00010100, v=010, v=0.
 В качестве номера позиции p допускаются только значения 0 (отобразить в младшем разряде индикатора) и 1 (в старшем). 
 Команда t=значение задаёт время в миллисекундах, в течение которого светится разряд индикатора, другой разряд в это время погашен. 
 По истечении заданного времени горящий разряд гаснет, а погашенный включается  */ 
 
 if (Serial.available()) {
    String key = Serial.readStringUntil('=');         
    String val = Serial.readStringUntil('\n');        
    //  Serial.println("Key: " + key);                
    //  Serial.println("Val: " + val);                
    
    if (key == "m" and isAllowed(val)) {  // обработка команды m=значение
     mode = val[0] - '0';           
     Serial.print("mode: ");
     Serial.println(mode); 
    }

    if (key == "p") { // обработка команды p=значение
     pos = val[0] - '0';
     if (pos < 0 or pos > 1) pos=0; // при p, отличном от 0 и 1, pos=0
     Serial.print("pos: ");
     Serial.println(pos);  
    }

   if (key == "v") { // обработка команды v=значение

    if (mode==0 and val.length() == 1) {      // обработка команды v=значение при mode=0 (цифры 0-9)
        byte digit = val[0] - '0';
        if (digit >=0 and digit <=9) dataToDisplay[pos] = Digits[digit];
    }
    
    if (mode==1) dataToDisplay[pos] = StrToBin(val);      // обработка команды v=значение при mode=1 (индивидуальные сегменты)
   }

   if (key == "t") {  // обработка команды t=значение
    interval = val.toInt(); /* Считывает цифры до первого не-цифрового символа.
                               Возвращает 0, если цифр не найдено или строка пуста.
                               Не сообщает об ошибке: при переполнении результат просто «обрезается» по правилам 32-битного знакового long.*/
   }
 }
}



bool isAllowed(String value) { // Проверяет, находится ли принятая строка value в списке modes

 bool result = false;
 for (byte i = 0; i < length_modes; i++) { 
   result = (value == modes[i]);
   if (result) break;
 }
 return result; 
}



void Display(byte position, byte digit) { // Отображает символ, заданный байтом digit, в позиции position двухразрядного индикатора

  // Принимает данные в виде двух байтов, гасит все сегменты индикатора, и в заданной позиции зажигает сегменты,
  // соответствующие единицам в двоичном представлении принятого байта
  // (сегмент A -- младший бит, и далее последовательно BCDEFG, точке H соответствует старший бит)

  /* Двухразрядный индикатор подключён к Arduino UNO: сегменты A-F к порту D (контакты 3-8), сегменты G, H к порту B (контакты 9, 10),
  общие электроды младшего и старшего разряда к порту B (контакты 11, 12).
  Соответственно, байт, подлежащий отображению, должен быть поделён на две части и распределён по портам, притом так,
  чтобы не изменились состояния выходов портов, к которым индикатор не подключён.
  Сначала выполняется гашение всех сегментов, затем зажигание нужных.
  В этой программе сегмент гасится подачей на него обратного напряжения (т.е. подачей на анод отрицательного потенциала по отношению
  к катоду). Такой подход требует, чтобы индикатор, подключённый напрямую к Arduino, выдерживал обратное напряжение 5 В, или сегменты
  должны быть шунтированы обратно включёнными кремниевыми диодами. 
  Алгоритм разделения принятого байта на две части и его выдачи в порты
  Для порта B
  byte b = digit >> 6; // сдвинуть принятый байт вправо на 6 позиций, чтобы два старших бита digit оказались младшими битами b 
  b |= 0b11111100;     // в старшие биты b поместить 6 единиц, сохранив два младших бита
  PORTB |= b;          // выдать два младших бита в PORTB, не затрагивая шесть старших
  Для порта D то же самое, но сдвиг влево на 2 бита. Запись в одну строку 
  PORTD |= (digit << 2) | 0b00000011; */

 const byte mask_B = 0b11111100;
 const byte mask_D = 0b00000011;
 byte mask_B_pos = 0b00000100 << position; // маска для выбора разряда индикатора -- нулевого или первого
 byte shiftedDigit_B = digit >> 6;
 byte shiftedDigit_D = digit << 2;

 if (COMMON_CATHODE) { // общий катод
   PORTB &= mask_B;                    // гасим по линиям сегментов, выставляя на них низкий уровень 
   PORTD &= mask_D;
   PORTB |= 0b00001100;                // гасим по линиям катодов, выставляя на них высокий уровень. На погашенных сегментах обратное напряжение!
   PORTB |= (shiftedDigit_B | mask_B); // подаём высокий уровень на сегменты, которые нужно зажечь
   PORTD |= (shiftedDigit_D | mask_D); 
   PORTB &= ~mask_B_pos;                // подаём низкий уровень на общий катод нужного разряда (задаётся параметром position)
  } 
 else { // общий анод (эта часть написана по аналогии, на реальной системе не проверялась, в отличие от части для общего катода)
   PORTB |= ~mask_B;                     // гасим по линиям сегментов, выставляя на них высокий уровень
   PORTD |= ~mask_D;
   PORTB &= 0b11110011;                  // гасим по линиям анодов, выставляя на них низкий уровень. На погашенных сегментах обратное напряжение! 
   PORTB &= (~shiftedDigit_B & ~mask_B); // подаём низкий уровень на сегменты, которые нужно зажечь
   PORTD &= (~shiftedDigit_D & ~mask_D);
   PORTB |= mask_B_pos;                  // подаём высокий уровень на общий анод нужного разряда (задаётся параметром position)
  };
}



byte StrToBin(String inString) { // Преобразует входную строку в байт

  /* Функция принимает строку из нулей и единиц длиной 1-8 символов и преобразует её в байт как двоичное число
  Если передано 0 или более 8 символов, если среди символов есть отличные от 0 и 1, то результатом является 0, что соответствует
  гашению всех сегментов индикатора */

 int len = inString.length();
 if (len < 1 or len > 8) return 0;
 byte result = 0;
 byte mask = 1;
 for (int i = len - 1; i >= 0; i--) {
  if (inString[i] != '0' and inString[i] != '1') return 0;
  if (inString[i] == '1') result = result|mask;
  mask = mask << 1;
 };
 return result;  
}


/*
Иллюстративная программа для управления двухразрядным семисегментным индикатором через последовательный порт.
Программа принимает через Serial Monitor в Arduino IDE и UART в Arduino UNO команду
установки режима отображения m=0 или m=1, команду выбора разряда индикатора p=значение, команду установки отображаемого значения v=значение,
команду установки длительности свечения разряда индикатора t=значение.
Значение, переданное в команде v, отображается на индикаторе по-разному в зависимости от режима, установленного командой m.

Если передана команда m=0, то устанавливается режим с декодированием. В этом режиме в команде v можно
передавать только цифры 0-9, и они будут отображаться на индикаторе в соответствии со схемой отображения,
заданной в массиве Digits.

Если передана команда m=1, то устанавливается режим без декодирования. В этом режиме в команде v
передаётся двоичное число, в котором каждый разряд управляет соответствующим сегментом индикатора. В этом
режиме можно отображать произвольную комбинацию сегментов, а не только цифры.

Разряд индикатора, данные для которого передаются командой v, выбирается командой p=значение.
Разряды индикатора загораются по очереди через интервал, заданный командой t. Например, при t=1000 младший разряд индикатора светится 1 с,
гаснет, включается старший разряд, светится 1 с, гаснет и т.д. в цикле. Если уменьшать t, то при некотором значении глаз, обладающий инерционностью,
перестанет различать переключение разрядов и будет видеть сначала мигающее, а затем и непрерывное свечение обоих разрядов. Такой последовательный, поразрядный вывод информации в индикатор, со
свечением в каждый момент времени только одного разряда индикатора, называется динамической индикацией, что противопоставляется статической индикации, при
которой каждый разряд индикатора имеет отдельные выводы сегментов и светится непрерывно.

Электрическая схема. Двухразрядный семисегментный индикатор с общим катодом или общим анодом подключён к плате Arduino UNO:
- общий электрод младшего и старшего разряда к пинам 11, 12 соответственно
- сегменты A, B, C, D, E, F, G и точка (сегмент H) к пинам 2-9 соответственно через токоограничивающие резисторы.
В программе до компиляции необходимо указать тип индикатора
(в строке #define COMMON_CATHODE false   // true для индикатора с общим катодом, false для индикатора с общим анодом)
 */

 